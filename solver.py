import numpy as np
from matplotlib import pyplot as plt

# Частота визуализации (каждые 30 итераций)
plot_every = 30

def main():
    # Размеры сетки: nx - ширина, ny - высота
    nx, ny = 300, 100
    # Время релаксации (влияет на вязкость жидкости)
    tau = 0.53
    # Общее количество итераций
    Nt = 3000

    # Параметры решетки D2Q9 (9 направлений)
    NL = 9
    # Скорости по x для каждого направления
    cxs = np.array([0, 0, 1, 1, 1, 0, -1, -1, -1])
    # Скорости по y для каждого направления
    cys = np.array([0, 1, 1, 0, -1, -1, -1, 0, 1])
    # Веса для каждого направления
    weights = np.array([4/9, 1/9, 1/36, 1/9, 1/36, 1/9, 1/36, 1/9, 1/36])
    
    # Инициализация функции распределения
    # np.random.randn: генерация случайных чисел с нормальным распределением
    # Создается 3D-массив размером [ny, nx, NL] со случайными возмущениями
    F = np.ones((ny, nx, NL)) + 0.01 * np.random.randn(ny, nx, NL)
    # Задаем начальное преимущественное направление течения (вправо)
    F[:, :, 3] = 2.3
    
    # Создание препятствия (цилиндра)
    # np.meshgrid: создание координатных сеток
    x, y = np.meshgrid(np.arange(nx), np.arange(ny))
    # Центр цилиндра
    cx, cy = nx // 4, ny // 2
    # Создание булевой маски цилиндра (True внутри круга)
    # np.square: возведение в квадрат, результат - массив той же формы
    cylinder = np.square(x - cx) + np.square(y - cy) < 169  # 13^2=169

    # Предвычисленные индексы для отражения частиц (bounce-back)
    bounce_indices = np.array([0, 5, 6, 7, 8, 1, 2, 3, 4])

    # Главный цикл симуляции
    for it in range(Nt):
        # Вывод прогресса каждые 100 итераций
        if it % 100 == 0:
            print(f"Итерация: {it}/{Nt}")
        
        # Граничные условия (фиксированное давление)
        # Правая граница: отражение для частиц, идущих влево
        F[:, -1, [6, 7, 8]] = F[:, -2, [6, 7, 8]]
        # Левая граница: отражение для частиц, идущих вправо
        F[:, 0, [2, 3, 4]] = F[:, 1, [2, 3, 4]]
        
        # Этап переноса (streaming)
        for i in range(NL):
            # np.roll: циклический сдвиг массива вдоль оси 1 (x)
            # shift=cxs[i]: величина сдвига зависит от направления скорости
            F[:, :, i] = np.roll(F[:, :, i], shift=cxs[i], axis=1)
            # Сдвиг вдоль оси 0 (y)
            F[:, :, i] = np.roll(F[:, :, i], shift=cys[i], axis=0)
        
        # Вычисление макроскопических величин
        # Плотность: сумма по всем направлениям (axis=2)
        # np.sum: суммирование элементов массива
        rho = np.sum(F, axis=2)
        # Скорость по x: взвешенная сумма cxs
        # F * cxs: поэлементное умножение (broadcasting)
        ux = np.sum(F * cxs, axis=2) / rho
        # Скорость по y: взвешенная сумма cys
        uy = np.sum(F * cys, axis=2) / rho
        
        # Обработка столкновений с препятствием (bounce-back)
        # F[cylinder]: выбор всех элементов, где cylinder=True
        # Применяем перестановку направлений для отражения
        F[cylinder] = F[cylinder][:, bounce_indices]
        
        # Обнуление скорости внутри препятствия
        ux[cylinder] = 0
        uy[cylinder] = 0

        # Вычисление равновесной функции распределения
        Feq = np.zeros_like(F)  # Создание массива нулей той же формы, что и F
        for i in range(NL):
            # Скалярное произведение скорости частицы и макроскопической скорости
            cu = cxs[i] * ux + cys[i] * uy
            # Формула равновесного распределения
            Feq[:, :, i] = rho * weights[i] * (1 + 3 * cu + 4.5 * np.square(cu) - 1.5 * (np.square(ux) + np.square(uy)))
        
        # Этап столкновений (collision)
        # Релаксация к равновесному состоянию
        F += - (1/tau) * (F - Feq)

        # Визуализация завихренности
        if it % plot_every == 0:
            # Вычисление частных производных для ротора (curl)
            # dfydx = d(uy)/dx (разность по x)
            dfydx = ux[2:, 1:-1] - ux[0:-2, 1:-1]
            # dfxdy = d(ux)/dy (разность по y)
            dfxdy = uy[1:-1, 2:] - uy[1:-1, 0:-2]
            # Ротор (curl) = d(uy)/dx - d(ux)/dy
            curl = dfydx - dfxdy
            
            # Визуализация завихренности
            # cmap="bwr": сине-бело-красная цветовая схема
            plt.imshow(curl, cmap="bwr", vmin=-0.1, vmax=0.1)
            plt.title(f"Завихренность (Итерация {it})")
            plt.pause(0.001)
            plt.clf()  # Очистка рисунка для следующего кадра

    plt.show()

if __name__ == "__main__":
    main()